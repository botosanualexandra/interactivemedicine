/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/models/muschi.glb 
*/

import React, { useState, useEffect } from 'react';
import * as THREE from 'three';
import { Box, OrbitControls, ScrollControls, Scroll, useScroll, Stats, Text, useGLTF, useAnimations} from '@react-three/drei';
import { animated, useSpring} from '@react-spring/three';
import { useGraph } from '@react-three/fiber'
import { SkeletonUtils } from 'three-stdlib'
import { Html } from '@react-three/drei';
import { useRef } from 'react';
import { useContext } from 'react';
import { muschiContext } from '../tabs/Muschi/Muschi.jsx'; // Adjust path as needed


function NODISPLAYMATERIAL(){
  return new THREE.MeshBasicMaterial({ visible: false });
}

function SOLIDMATERIAL(color){
  // Accepts a hex number or THREE.Color, not a string
  return new THREE.MeshBasicMaterial({ color: color || 0x000000, wireframe: false });
}

function BRAINMATERIAL(){
  const material = new THREE.MeshStandardMaterial({
    color: 0xFF6FB5,
    roughness: 0.5,
    metalness: 0.1,
  });
  return material;
}

export function MODEL_Muscles(props) {
  const group = React.useRef()
  const { scene, animations } = useGLTF('./models/muschi.glb')
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene])
  const { nodes, materials } = useGraph(clone)
  const { actions, names } = useAnimations(animations, group)

  const [hoveredLeft, setHoveredLeft] = useState(false);
  const [hoveredCenter, setHoveredCenter] = useState(false);
  const [hoveredRight, setHoveredRight] = useState(false);

  const { focusedGroup, setFocusedGroup } = useContext(muschiContext ? muschiContext : { focusedGroup: null, setFocusedGroup: () => {} });

  useEffect(() => {
    if(focusedGroup !== null){ 
      document.body.style.cursor = 'auto';
      return;
    }
    document.body.style.cursor = (hoveredLeft || hoveredCenter || hoveredRight) ? 'pointer' : 'auto';
  }, [hoveredLeft, hoveredCenter, hoveredRight, focusedGroup]);

  const currentPage = props.currentPage || 0;
  const sendImpulse = props.sendImpulse || (() => {});
  const selectedArmType = props.selectedArmType || 0;
  const forceAnimationElapsedTime = props.elapsedTime || 0;

  useEffect(() => {
    // Only scrub ForceArmRigAction when forceSpring is visible (currentPage 1 or 6)
    const action = actions['ForceArmRigAction'];
    if (action && (currentPage === 1 || currentPage === 6)) {
      const duration = action.getClip().duration;
      // Map slider (1-100) to animation duration
      let t = forceAnimationElapsedTime;
      if (t > 1.5) t = t / 100 * duration; // If slider is 1-100, scale to duration
      t = Math.max(0, Math.min(duration, t));
      action.enabled = true;
      action.play();
      action.time = t;
      action.paused = true;
    }
  }, [forceAnimationElapsedTime, actions, currentPage]);

  React.useEffect(() => {
    if (materials.Impulse) {
      materials.Impulse.emissive = new THREE.Color(0x27E4F5);
      materials.Impulse.emissiveIntensity = 10.0;
    }
    // Enable backface culling for all mesh materials
    if (group.current) {
      group.current.traverse((child) => {
        if (child.isMesh && child.material) {
          child.material.side = THREE.FrontSide;
        }
      });
    }
  }, [materials]);

  useEffect(() => {
    if (names && names.length > 0) {
      names.forEach(name => {
        if (actions[name]) {
          if (name === 'NerveArmRigAction') {
            actions[name].setLoop(THREE.LoopOnce, 0);
            actions[name].clampWhenFinished = true;
            actions[name].reset().play();
            return;
          }
          if (name === 'Action') {
            actions[name].setLoop(THREE.LoopRepeat, 0);
            return;
          }
          if (name === 'ForceArmRigAction') {
            actions[name].paused = true; // Handled by slider effect
            return;
          }
          // Do not auto-play ForceArmRigAction here; handled by slider effect
          actions[name].setLoop(THREE.LoopRepeat, Infinity);
          actions[name].reset().play();
        }
      });
    }
    return () => {
      if (names && names.length > 0) {
        names.forEach(name => {
          if (actions[name]) actions[name].stop();
        });
      }
    };
  }, [actions, names, props.selectedArmType]);

  const focusedPosition = [-2, 0.5, 3];

  const leftSpring = useSpring({
    position: focusedGroup === 'left'
      ? focusedPosition
      : [-3, currentPage === 2 && hoveredLeft ? 0.3 : 0, 0],
    scale:
      focusedGroup === null
        ? (currentPage === 2 ? 1 : 0)
        : focusedGroup === 'left'
          ? 1
          : 0,
    config: { mass: 1, tension: 180, friction: 18 }
  });
  const rightSpring = useSpring({
    position: focusedGroup === 'right'
      ? focusedPosition
      : [3, currentPage === 2 && hoveredRight ? 0.3 : 0, 0],
    scale:
      focusedGroup === null
        ? (currentPage === 2 ? 1 : 0)
        : focusedGroup === 'right'
          ? 1
          : 0,
    config: { mass: 1, tension: 180, friction: 18 }
  });
  const centerSpring = useSpring({
    position: focusedGroup === 'center'
      ? focusedPosition
      : [0, currentPage === 2 && hoveredCenter ? 0.3 : 0, 0],
    scale:
      focusedGroup === null
        ? (currentPage === 2 ? 1 : 0)
        : focusedGroup === 'center'
          ? 1
          : 0,
    config: { mass: 1, tension: 180, friction: 18 }
  });

  const muscleFiberSpring = useSpring({
    scale: currentPage === 3 ? 1 : 0,
    config: { mass: 1, tension: 180, friction: 18 }
  });

  const izotonicăSpring = useSpring({
    scale: currentPage === 4 ? 1 *  (selectedArmType === 1 ? 1 : 0) : 0,
    config: { mass: 1, tension: 180, friction: 18 }
  });

  const izometricăSpring = useSpring({
    scale: currentPage === 4 ? 1 * (selectedArmType === 2 ? 1 : 0) : 0,
    config: { mass: 1, tension: 180, friction: 18 }
  });

  const excentricăSpring = useSpring({
    scale: currentPage === 4 ? 1 * (selectedArmType === 3 ? 1 : 0) : 0,
    config: { mass: 1, tension: 180, friction: 18 }
  });

  const nerveSpring = useSpring({
    scale: currentPage === 5 ? 1 : 0,
    config: { mass: 1, tension: 180, friction: 18 }
  });

  const forceSpring = useSpring({
    scale: currentPage === 1 || currentPage === 6 ? 1 : 0,
    config: { mass: 1, tension: 180, friction: 18 }
  });

  sendImpulse.current = () => {
    // Trigger impulse animation
    console.log('Impulse triggered');
    const impulseAction = actions['Action'];
    if (impulseAction) {
      impulseAction.reset().play();
    }

    const armAction = actions['NerveArmRigAction'];
    if (armAction) {
      armAction.setLoop(THREE.LoopOnce, 0);
      armAction.clampWhenFinished = true;
      armAction.reset().play();
    }
  }

  return (
    <group ref={group} {...props} dispose={null}>
      <animated.group
        position={leftSpring.position}
        scale={leftSpring.scale}
        onPointerOver={() => currentPage === 2 && setHoveredLeft(true)}
        onPointerOut={() => setHoveredLeft(false)}
        onClick={focusedGroup ? undefined : () => setFocusedGroup('left')}
      >
        <mesh geometry={nodes.skeletalmuscle.geometry} material={materials.Muscle} />
        <mesh geometry={nodes.skeletalmuscle_1.geometry} material={materials.Rock} />
        <mesh geometry={nodes.skeletalmuscle_2.geometry} material={NODISPLAYMATERIAL()} />
        
        {hoveredLeft && focusedGroup !== 'left' && (
          <Text
          position={[0, 1, 0]}
          fontSize={0.25}
          color="white"
          anchorX="center"
          anchorY="middle"
        >
          Scheletici 
        </Text>
        )}
      </animated.group>

      <animated.group
        position={rightSpring.position}
        scale={rightSpring.scale}
        onPointerOver={() => currentPage === 2 && setHoveredRight(true)}
        onPointerOut={() => setHoveredRight(false)}
        onClick={focusedGroup ? undefined : () => setFocusedGroup('right')}
      >
        <mesh geometry={nodes.smoothmuscle.geometry} material={materials['Muscle no Texture']} />
        <mesh geometry={nodes.smoothmuscle_1.geometry} material={materials.Rock} />
        <mesh geometry={nodes.smoothmuscle_2.geometry} material={NODISPLAYMATERIAL()} />
        
        {hoveredRight && focusedGroup !== 'right' && (
        <Text
          position={[0, 1, 0]}
          fontSize={0.25}
          color="white"
          anchorX="center"
          anchorY="middle"
        >
          Cardiaci
        </Text>
        )}
      </animated.group>

      <animated.group
        position={centerSpring.position}
        scale={centerSpring.scale}
        onPointerOver={() => currentPage === 2 && setHoveredCenter(true)}
        onPointerOut={() => setHoveredCenter(false)}
        onClick={focusedGroup ? undefined : () => setFocusedGroup('center')}
      >
        <mesh geometry={nodes.cardiacmuscle.geometry} material={materials.Muscle} />
        <mesh geometry={nodes.cardiacmuscle_1.geometry} material={materials.Rock} />
        <mesh geometry={nodes.cardiacmuscle_2.geometry} material={NODISPLAYMATERIAL()} />
        
        {hoveredCenter && focusedGroup !== 'center' && (
        <Text
          position={[0, 1, 0]}
          fontSize={0.25}
          color="white"
          anchorX="center"
          anchorY="middle"
        >
          Netezi 
        </Text>
        )}
      </animated.group>

      <animated.group name="Musle_Fiber_Armature" scale={muscleFiberSpring.scale} rotation={[0, Math.PI, 0]}>
        <group name="musclefibermodel">
          <skinnedMesh name="Cylinder004" geometry={nodes.Cylinder004.geometry} material={materials['Muscle no Texture']} skeleton={nodes.Cylinder004.skeleton} />
          <skinnedMesh name="Cylinder004_1" geometry={nodes.Cylinder004_1.geometry} material={materials['Muscle Inside']} skeleton={nodes.Cylinder004_1.skeleton} />
        </group>
        <primitive object={nodes.Bone} />
        <mesh name="BoneForMuscle" geometry={nodes.BoneForMuscle.geometry} material={materials.Bone} scale={[1.1, .9, .9]}/>
      </animated.group>
      
      <group rotation={[0, -Math.PI / 2, 0]} position={[0, -3, 0]} scale={2}>
        <animated.group name="IzoArmRig" scale={izotonicăSpring.scale} position={[0, 1.5, 0]} rotation={[0, Math.PI / 2.5, 0]}>
          <primitive object={nodes.mixamorig1LeftShoulder} />
          <primitive object={nodes.elbowIK} />
          <primitive object={nodes.handIK} />
          <skinnedMesh name="izomodel" geometry={nodes.izomodel.geometry} material={materials['Skin']} skeleton={nodes.izomodel.skeleton} />
        </animated.group>
  
        <animated.group name="MetricArmRig" scale={izometricăSpring.scale}>
          <primitive object={nodes.mixamorig1LeftShoulder_1} />
          <primitive object={nodes.elbowIK_1} />
          <primitive object={nodes.handIK_1} />
          <skinnedMesh name="metricmodel" geometry={nodes.metricmodel.geometry} material={materials['Material.001']} skeleton={nodes.metricmodel.skeleton} />
        </animated.group>

        <animated.group name="ExcentricArmRig" scale={excentricăSpring.scale} position={[0, 6, -2]} rotation={[0, Math.PI / 2.5, 0]}>
          <primitive object={nodes.mixamorig1LeftShoulder_2} />
          <primitive object={nodes.elbowIK_2} />
          <primitive object={nodes.handIK_2} />
          <skinnedMesh name="excentricarmmodel" geometry={nodes.excentricarmmodel.geometry} material={materials['Material.002']} skeleton={nodes.excentricarmmodel.skeleton} />
        </animated.group>
      </group>
      
      <group rotation={[0, Math.PI / 1, 0]}>
        <animated.group scale={nerveSpring.scale}>
          <group name="NerveArmRig" rotation={[-Math.PI, 0, 0]} scale={-1}>
            <primitive object={nodes.mixamorig1LeftShoulder_3} />
            <primitive object={nodes.elbowIK_3} />
            <primitive object={nodes.handIK_3} />
            <skinnedMesh name="nervearmmodel" geometry={nodes.nervearmmodel.geometry} material={materials['Material.003']} skeleton={nodes.nervearmmodel.skeleton} />
          </group>
          <group name="Brain" rotation={[-Math.PI, Math.PI / 3, 0]} scale={-1.3} position={[0, -2, 0]}>
            <mesh name="brainmodel" geometry={nodes.brainmodel.geometry} material={BRAINMATERIAL()} />
            <mesh name="brainmodel_1" geometry={nodes.brainmodel_1.geometry} material={materials.Brain2} />
          </group>
          <mesh name="Nerve" geometry={nodes.Nerve.geometry} material={SOLIDMATERIAL(0x3B0B2F)} rotation={[-Math.PI, 0, 0]} scale={-1} />
          <mesh name="Impulse" geometry={nodes.Impulse.geometry} material={materials.Impulse} position={[0, 5.167, -0.16]} rotation={[-Math.PI / 4, 0, 0]} />
          <group name="Nerve_Path" rotation={[-Math.PI, 0, 0]} scale={-1} />
        </animated.group>
      </group>
      
      <group position={[-4, 2, 0]} rotation={[0, Math.PI / -1.2, 0]} scale={2}> 
        <animated.group name="ForceArmRig" scale={forceSpring.scale}>
          <primitive object={nodes.mixamorig1LeftShoulder_4} />
          <primitive object={nodes.elbowIK_4} />
          <primitive object={nodes.handIK_4} />
          <group name="forcearmmodel">
            <skinnedMesh name="Mesh004" geometry={nodes.Mesh004.geometry} material={materials['Skin.001']} skeleton={nodes.Mesh004.skeleton} />
            <skinnedMesh name="Mesh004_1" geometry={nodes.Mesh004_1.geometry} material={materials['Muscle no Texture.001']} skeleton={nodes.Mesh004_1.skeleton} />
            <skinnedMesh name="Mesh004_2" geometry={nodes.Mesh004_2.geometry} material={materials['Muscle Inside.001']} skeleton={nodes.Mesh004_2.skeleton} />
            <skinnedMesh name="Mesh004_3" geometry={nodes.Mesh004_3.geometry} material={materials['Skin Inside']} skeleton={nodes.Mesh004_3.skeleton} />
          </group>
        </animated.group>
      </group>
    </group>
  );
}

useGLTF.preload('./models/muschi.glb')

export default MODEL_Muscles

