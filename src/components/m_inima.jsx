/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/models/inima.glb 
*/

import React, { useEffect, useRef } from 'react'
import { useGLTF } from '@react-three/drei'
import { useFrame } from '@react-three/fiber'
import * as THREE from 'three'

// Create a light-reactive heart material
function createHeartMaterial() {
  return new THREE.MeshPhysicalMaterial({
    color: '#a10000', // Dark red color for the heart
    metalness: 0.1,
    roughness: 0.3,
    clearcoat: 0.2,
    clearcoatRoughness: 0.1,
    emissive: '#e70000', // Subtle red glow
    emissiveIntensity: .5,
    side: THREE.FrontSide,
    transparent: false,
    opacity: 1
  })
}

export function MODEL_Inima(props) {
  const { bpm = 72, ...otherProps } = props // Default 72 BPM (normal resting heart rate)
  const { nodes, materials } = useGLTF('./models/inima.glb')
  const heartMaterial = createHeartMaterial()
  const meshRef = useRef()
  const timeRef = useRef(0)
  const currentScaleRef = useRef(1) // For smooth interpolation
  const targetScaleRef = useRef(1)

  // Simulate realistic heartbeat animation
  useFrame((state, delta) => {
    if (meshRef.current && heartMaterial) {
      // Convert BPM to animation speed multiplier
      // Formula: (BPM / 60) * 2Ï€ for full cardiac cycle timing
      const heartRateMultiplier = (bpm / 60) * Math.PI
      timeRef.current += delta * heartRateMultiplier
      
      // Create cardiac cycle with lub-dub pattern
      const cycle = timeRef.current % (Math.PI * 2)
      let heartbeat = 0
      
      // Systole (lub) - strong contraction
      if (cycle < Math.PI * 0.25) {
        const phase = cycle / (Math.PI * 0.25)
        heartbeat = Math.sin(phase * Math.PI) * Math.pow(phase, 0.5)
      }
      // Brief pause
      else if (cycle < Math.PI * 0.4) {
        heartbeat = 0.1
      }
      // Diastole (dub) - weaker secondary pulse
      else if (cycle < Math.PI * 0.6) {
        const phase = (cycle - Math.PI * 0.4) / (Math.PI * 0.2)
        heartbeat = Math.sin(phase * Math.PI) * 0.4
      }
      // Rest phase
      else {
        const restPhase = (cycle - Math.PI * 0.6) / (Math.PI * 1.4)
        heartbeat = Math.max(0, 0.0 * (0 - restPhase))
      }
      
      // Calculate adaptive scale intensity based on BPM (reduce scaling at high BPMs)
      const scaleIntensity = Math.max(0.1, Math.min(0.25, 0.3 - (bpm - 60) * 0.002))
      const targetScale = 1 + heartbeat * scaleIntensity
      targetScaleRef.current = targetScale
      
      // Smooth interpolation for scale changes (prevents jerkiness)
      const lerpSpeed = Math.min(255, 5 + (bpm / 25)) // Adaptive lerp speed
      currentScaleRef.current = THREE.MathUtils.lerp(
        currentScaleRef.current, 
        targetScaleRef.current, 
        delta * lerpSpeed
      )
      
      // Apply smoothed scale
      meshRef.current.scale.setScalar(currentScaleRef.current)
      
      // Apply heartbeat to material glow (also smoothed for high BPMs)
      const glowIntensity = Math.max(0.2, 0.2 - (bpm - 60) * 0.001)
      heartMaterial.emissiveIntensity = 0.25 + heartbeat * glowIntensity
    }
  })

  return (
    <group {...otherProps} dispose={null}>
      <mesh ref={meshRef} geometry={nodes.Sphere.geometry} material={heartMaterial} />
    </group>
  )
}

useGLTF.preload('./models/inima.glb')

export default MODEL_Inima
